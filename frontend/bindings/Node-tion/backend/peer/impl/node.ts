// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

/**
 * node implements a peer to build a Peerster system
 * 
 * - implements peer.Peer
 * @module
 */

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import {Call as $Call, Create as $Create} from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as peer$0 from "../models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as transport$0 from "../../transport/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as types$0 from "../../types/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as io$0 from "../../../../io/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as regexp$0 from "../../../../regexp/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as sync$0 from "../../../../sync/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as time$0 from "../../../../time/models.js";

/**
 * AckMessageCallback handles the AckMessage
 */
export function AckMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(885122498, msg, pkt) as any;
    return $resultPromise;
}

export function AckTicker(packetHeader: transport$0.Header | null, payload: transport$0.Message): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1390926644, packetHeader, payload) as any;
    return $resultPromise;
}

/**
 * AddBlockAndName adds the block and name to the blockchain and naming store
 */
export function AddBlockAndName(block: types$0.BlockchainBlock): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(77960949, block) as any;
    return $resultPromise;
}

/**
 * AddPeer implements peer.Messaging
 */
export function AddPeer(...addr: string[]): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(98372272, addr) as any;
    return $resultPromise;
}

/**
 * AddRequest adds a request to the requests map
 */
export function AddRequest(requestID: string): Promise<boolean> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3924234341, requestID) as any;
    return $resultPromise;
}

export function AntiEntropyTicker(): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1187933420) as any;
    return $resultPromise;
}

/**
 * ApplyOperation applies a CRDT operation to the document.
 */
export function ApplyOperation(op: types$0.CRDTOperation): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1869059968, op) as any;
    return $resultPromise;
}

/**
 * Broadcast implements peer.Messaging
 */
export function Broadcast(msg: transport$0.Message): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3844491980, msg) as any;
    return $resultPromise;
}

/**
 * CRDTOperationsMessageCallback handles the CRDTOperationsMessage
 */
export function CRDTOperationsMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(4276864942, msg, pkt) as any;
    return $resultPromise;
}

/**
 * ChatMessageCallback logs the chat message
 */
export function ChatMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3874487965, msg, pkt) as any;
    return $resultPromise;
}

/**
 * CreateBudgetMap creates a map of neighbors to their budget.
 */
export function CreateBudgetMap(budget: number, numNeighbors: number): Promise<{ [_: `${number}`]: number }> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1979970862, budget, numNeighbors) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType0($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * DataReplyMessageCallback handles the DataReplyMessage
 */
export function DataReplyMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(644385009, msg, pkt) as any;
    return $resultPromise;
}

/**
 * DataRequestMessageCallback handles the DataRequestMessage
 */
export function DataRequestMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(470990274, msg, pkt) as any;
    return $resultPromise;
}

/**
 * DeleteAck deletes the channel for a packet
 */
export function DeleteAck(packetID: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1445430511, packetID) as any;
    return $resultPromise;
}

/**
 * DeleteDataReplyChan deletes the reply channel for a request
 */
export function DeleteDataReplyChan(requestID: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2342103086, requestID) as any;
    return $resultPromise;
}

/**
 * DeleteSearchReplyChan deletes the reply channel for a search request
 */
export function DeleteSearchReplyChan(requestID: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2784018550, requestID) as any;
    return $resultPromise;
}

/**
 * Download implements DataSharing
 */
export function Download(metahash: string): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(4184632497, metahash) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $Create.ByteSlice($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * DownloadElement downloads a single element from the data store.
 */
export function DownloadElement(key: string): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(375651155, key) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $Create.ByteSlice($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * EmptyMessageCallback handles the EmptyMessage
 */
export function EmptyMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(394318230, msg, pkt) as any;
    return $resultPromise;
}

/**
 * ExpandRing expands the ring.
 */
export function ExpandRing(conf: peer$0.ExpandingRing, neigh: string, reg: regexp$0.Regexp, budget: number, wait: sync$0.WaitGroup | null, match: any): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(570559215, conf, neigh, reg, budget, wait, match) as any;
    return $resultPromise;
}

/**
 * ForwardSearchRequest handles the ForwardSearchRequest
 */
export function ForwardSearchRequest(budget: number, src: string, reg: regexp$0.Regexp | null, req: types$0.SearchRequestMessage | null): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1332410583, budget, src, reg, req) as any;
    return $resultPromise;
}

/**
 * GetAck returns the channel for a packet
 */
export function GetAck(packetID: string): Promise<[any, boolean]> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1470283024, packetID) as any;
    return $resultPromise;
}

/**
 * GetBlockOps returns the block of the CRDT
 */
export function GetBlockOps(docID: string, blockID: string): Promise<types$0.CRDTOperation[]> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1412350908, docID, blockID) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType2($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

export function GetCRDTState(docID: string): Promise<number> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3752222279, docID) as any;
    return $resultPromise;
}

/**
 * GetCatalog implements peer.DataSharing
 */
export function GetCatalog(): Promise<peer$0.Catalog> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1899868482) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType3($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * GetDocumentOps returns the document of the CRDT
 */
export function GetDocumentOps(docID: string): Promise<{ [_: string]: types$0.CRDTOperation[] }> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2077357450, docID) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType6($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * GetEditor returns the editor of the CRDT
 */
export function GetEditor(): Promise<peer$0.Editor> & { cancel(): void } {
    let $resultPromise = $Call.ByID(298692850) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType7($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * GetFileInfo returns the FileInfo for the given name
 */
export function GetFileInfo(name: string, metahash: string): Promise<types$0.FileInfo> & { cancel(): void } {
    let $resultPromise = $Call.ByID(4066099529, name, metahash) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType9($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * GetNeighbors returns the neighbors of the node
 */
export function GetNeighbors(...excluding: string[]): Promise<string[]> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1374211102, excluding) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType10($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * GetRandNeighsFromBudget returns a random subset of neighbors.
 */
export function GetRandNeighsFromBudget(budget: number, ...excluding: string[]): Promise<string[]> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1668706329, budget, excluding) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType10($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * GetRandomNeighborFromRoutingTable Function to get a random neighbor
 */
export function GetRandomNeighborFromRoutingTable(source: string): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3433882196, source) as any;
    return $resultPromise;
}

export function GetRandomPeerFromCatalog(key: string): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(4002232387, key) as any;
    return $resultPromise;
}

/**
 * GetRoutingTable implements peer.Messaging
 */
export function GetRoutingTable(): Promise<peer$0.RoutingTable> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2793839337) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType11($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

export function HeartbeatTicker(): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1411076297) as any;
    return $resultPromise;
}

/**
 * HexEncode returns the hex-encoded hash of the data.
 */
export function HexEncode(data: string): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2328619240, data) as any;
    return $resultPromise;
}

export function Listen(): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3975338830) as any;
    return $resultPromise;
}

/**
 * PaxosAcceptMessageCallback handles the PaxosAcceptMessage
 */
export function PaxosAcceptMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1349230424, msg, pkt) as any;
    return $resultPromise;
}

/**
 * PaxosLoop executes the Paxos loop.
 */
export function PaxosLoop(name: string, mh: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2404378718, name, mh) as any;
    return $resultPromise;
}

/**
 * PaxosPrepareMessageCallback handles the PaxosPrepareMessage
 */
export function PaxosPrepareMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1631261725, msg, pkt) as any;
    return $resultPromise;
}

/**
 * PaxosPromiseMessageCallback handles the PaxosPromiseMessage
 */
export function PaxosPromiseMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2349125275, msg, pkt) as any;
    return $resultPromise;
}

/**
 * PaxosProposeMessageCallback handles the PaxosProposeMessage
 */
export function PaxosProposeMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2063327458, msg, pkt) as any;
    return $resultPromise;
}

/**
 * PrivateMessageCallback handles the PrivateMessage
 */
export function PrivateMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2467995964, msg, pkt) as any;
    return $resultPromise;
}

/**
 * ProcessMsg handles the message if it's for this node.
 */
export function ProcessMsg(pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(611689191, pkt) as any;
    return $resultPromise;
}

/**
 * ProcessRumor processes the rumor
 */
export function ProcessRumor(rumor: types$0.Rumor, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1427893691, rumor, pkt) as any;
    return $resultPromise;
}

/**
 * RelayMsg relays the message to its next hop.
 */
export function RelayMsg(pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3079934143, pkt) as any;
    return $resultPromise;
}

/**
 * RemoteDownload downloads a single element from a remote peer.
 */
export function RemoteDownload(key: string): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2014138815, key) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $Create.ByteSlice($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * RemovePeerFromCatalog removes a peer from the catalog
 */
export function RemovePeerFromCatalog(key: string, peer: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3707813884, key, peer) as any;
    return $resultPromise;
}

/**
 * Resolve implements DataSharing
 */
export function Resolve(name: string): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2132149035, name) as any;
    return $resultPromise;
}

/**
 * RumorsMessageCallback handles the RumorsMessage
 */
export function RumorsMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2372496993, msg, pkt) as any;
    return $resultPromise;
}

export function SaveTransactions(transactions: types$0.CRDTOperationsMessage): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(305668657, transactions) as any;
    return $resultPromise;
}

/**
 * SearchAll implements DataSharing
 */
export function SearchAll(reg: regexp$0.Regexp, budget: number, timeout: time$0.Duration): Promise<string[]> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3253980936, reg, budget, timeout) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType10($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * SearchFirst implements DataSharing
 */
export function SearchFirst(pattern: regexp$0.Regexp, conf: peer$0.ExpandingRing): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2338046181, pattern, conf) as any;
    return $resultPromise;
}

/**
 * SearchFirstLocal searches for the first file that matches the pattern.
 */
export function SearchFirstLocal(pattern: regexp$0.Regexp): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3255832584, pattern) as any;
    return $resultPromise;
}

/**
 * SearchMatch looks for filenames that match the pattern.
 */
export function SearchMatch(reg: regexp$0.Regexp): Promise<string[]> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2276376330, reg) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType10($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * SearchReplyMessageCallback handles the SearchReplyMessage
 */
export function SearchReplyMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3764048213, msg, pkt) as any;
    return $resultPromise;
}

/**
 * SearchRequestMessageCallback handles the SearchRequestMessage
 */
export function SearchRequestMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(488819814, msg, pkt) as any;
    return $resultPromise;
}

/**
 * SendAckMessage sends an AckMessage to the origin
 */
export function SendAckMessage(pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(582096831, pkt) as any;
    return $resultPromise;
}

/**
 * SendDataRequestMessage sends a DataRequestMessage to the neighbor.
 */
export function SendDataRequestMessage(randPeer: string, metahash: string, requestID: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1707232023, randPeer, metahash, requestID) as any;
    return $resultPromise;
}

/**
 * SendHeartbeat sends a heartbeat
 */
export function SendHeartbeat(): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(747777357) as any;
    return $resultPromise;
}

/**
 * SendMsg sends a message to the destination.
 */
export function SendMsg(dest: string, msg: types$0.Message): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1838147200, dest, msg) as any;
    return $resultPromise;
}

/**
 * SendRumorsMessage sends a RumorsMessage to the source neighbor
 */
export function SendRumorsMessage(pkt: transport$0.Packet, missingRumors: types$0.Rumor[]): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(209719744, pkt, missingRumors) as any;
    return $resultPromise;
}

/**
 * SendRumorsMessageRand sends a RumorsMessage to a random neighbor
 */
export function SendRumorsMessageRand(msg: transport$0.Message, source: string): Promise<transport$0.Header> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2834915615, msg, source) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType13($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * SendSearchRequestMessage sends a SearchRequestMessage to the neighbor.
 */
export function SendSearchRequestMessage(neigh: string, r: regexp$0.Regexp, b: number, requestID: string, origin: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1156822463, neigh, r, b, requestID, origin) as any;
    return $resultPromise;
}

/**
 * SendStatusMessage sends a StatusMessage to the neighbor
 */
export function SendStatusMessage(neighbor: string, peerSeq: { [_: string]: number }): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2016518552, neighbor, peerSeq) as any;
    return $resultPromise;
}

/**
 * SendWithProbability sends a StatusMessage to a random neighbor with a probability of ContinueMongering
 */
export function SendWithProbability(pkt: transport$0.Packet, peerSeq: { [_: string]: number }): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2123773290, pkt, peerSeq) as any;
    return $resultPromise;
}

/**
 * SetAck sets the channel for a packet
 */
export function SetAck(packetID: string, ticker: any): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(4136925668, packetID, ticker) as any;
    return $resultPromise;
}

/**
 * SetDataReplyChan sets the reply channel for a request
 */
export function SetDataReplyChan(requestID: string, replyChan: any): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2033117209, requestID, replyChan) as any;
    return $resultPromise;
}

/**
 * SetRoutingEntry implements peer.Messaging
 */
export function SetRoutingEntry(origin: string, relayAddr: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(4141730349, origin, relayAddr) as any;
    return $resultPromise;
}

/**
 * SetSearchReplyChan sets the reply channel for a search request
 */
export function SetSearchReplyChan(requestID: string, replyChan: any): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(1936223513, requestID, replyChan) as any;
    return $resultPromise;
}

/**
 * SplitMetafile splits the metafile into chunks.
 */
export function SplitMetafile(metafile: string): Promise<string[]> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3678909328, metafile) as any;
    let $typingPromise = $resultPromise.then(($result) => {
        return $$createType10($result);
    }) as any;
    $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
    return $typingPromise;
}

/**
 * Start implements peer.Service
 */
export function Start(): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3230404871) as any;
    return $resultPromise;
}

/**
 * StatusMessageCallback handles the StatusMessage
 */
export function StatusMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2446481401, msg, pkt) as any;
    return $resultPromise;
}

/**
 * Stop implements peer.Service
 */
export function Stop(): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(3062450605) as any;
    return $resultPromise;
}

/**
 * TLCMessageCallback handles the TLCMessage
 */
export function TLCMessageCallback(msg: types$0.Message, pkt: transport$0.Packet): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2110166506, msg, pkt) as any;
    return $resultPromise;
}

/**
 * TLCStepReset resets the proposer, acceptor, and logical clock maxID
 */
export function TLCStepReset(): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2880454479) as any;
    return $resultPromise;
}

/**
 * Tag implements DataSharing
 */
export function Tag(name: string, mh: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2621664955, name, mh) as any;
    return $resultPromise;
}

/**
 * TryBroadcast broadcasts the message if not already broadcasted
 */
export function TryBroadcast(msg: types$0.Message): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2142131289, msg) as any;
    return $resultPromise;
}

/**
 * Unicast implements peer.Messaging
 */
export function Unicast(dest: string, msg: transport$0.Message): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(704809522, dest, msg) as any;
    return $resultPromise;
}

/**
 * UpdateCatalog implements peer.DataSharing
 */
export function UpdateCatalog(key: string, peer: string): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2253372467, key, peer) as any;
    return $resultPromise;
}

/**
 * UpdateEditor updates the editor of the CRDT
 */
export function UpdateEditor(ops: types$0.CRDTOperation[]): Promise<void> & { cancel(): void } {
    let $resultPromise = $Call.ByID(412191173, ops) as any;
    return $resultPromise;
}

/**
 * Upload implements DataSharing
 */
export function Upload(data: io$0.Reader): Promise<string> & { cancel(): void } {
    let $resultPromise = $Call.ByID(2620755668, data) as any;
    return $resultPromise;
}

// Private type creation functions
const $$createType0 = $Create.Map($Create.Any, $Create.Any);
const $$createType1 = types$0.CRDTOperation.createFrom;
const $$createType2 = $Create.Array($$createType1);
var $$createType3 = (function $$initCreateType3(...args): any {
    if ($$createType3 === $$initCreateType3) {
        $$createType3 = $$createType5;
    }
    return $$createType3(...args);
});
const $$createType4 = $Create.Map($Create.Any, $Create.Any);
const $$createType5 = $Create.Map($Create.Any, $$createType4);
const $$createType6 = $Create.Map($Create.Any, $$createType2);
var $$createType7 = (function $$initCreateType7(...args): any {
    if ($$createType7 === $$initCreateType7) {
        $$createType7 = $$createType8;
    }
    return $$createType7(...args);
});
const $$createType8 = $Create.Map($Create.Any, $$createType6);
const $$createType9 = types$0.FileInfo.createFrom;
const $$createType10 = $Create.Array($Create.Any);
var $$createType11 = (function $$initCreateType11(...args): any {
    if ($$createType11 === $$initCreateType11) {
        $$createType11 = $$createType12;
    }
    return $$createType11(...args);
});
const $$createType12 = $Create.Map($Create.Any, $Create.Any);
const $$createType13 = transport$0.Header.createFrom;
