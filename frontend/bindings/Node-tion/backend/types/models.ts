// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import {Create as $Create} from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as transport$0 from "../transport/models.js";

/**
 * BlockchainBlock defines the content of a block in the blockchain.
 */
export class BlockchainBlock {
    /**
     * Index is the index of the block in the blockchain, starting at 0 for the
     * first block.
     */
    "Index": number;

    /**
     * Hash is SHA256(Index || v.Filename || v.Metahash || Prevhash)
     * use crypto/sha256
     */
    "Hash": string;
    "Value": PaxosValue;

    /**
     * PrevHash is the SHA256 hash of the previous block
     */
    "PrevHash": string;

    /** Creates a new BlockchainBlock instance. */
    constructor($$source: Partial<BlockchainBlock> = {}) {
        if (!("Index" in $$source)) {
            this["Index"] = 0;
        }
        if (!("Hash" in $$source)) {
            this["Hash"] = "";
        }
        if (!("Value" in $$source)) {
            this["Value"] = (new PaxosValue());
        }
        if (!("PrevHash" in $$source)) {
            this["PrevHash"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new BlockchainBlock instance from a string or object.
     */
    static createFrom($$source: any = {}): BlockchainBlock {
        const $$createField1_0 = $Create.ByteSlice;
        const $$createField2_0 = $$createType0;
        const $$createField3_0 = $Create.ByteSlice;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Hash" in $$parsedSource) {
            $$parsedSource["Hash"] = $$createField1_0($$parsedSource["Hash"]);
        }
        if ("Value" in $$parsedSource) {
            $$parsedSource["Value"] = $$createField2_0($$parsedSource["Value"]);
        }
        if ("PrevHash" in $$parsedSource) {
            $$parsedSource["PrevHash"] = $$createField3_0($$parsedSource["PrevHash"]);
        }
        return new BlockchainBlock($$parsedSource as Partial<BlockchainBlock>);
    }
}

export type CRDTOp = any;

export class CRDTOperation {
    "Type": string;
    "BlockType": string;
    "Origin": string;

    /**
     * Operation number, corresponding to the last operation + 1 at each new operation
     */
    "OperationId": number;
    "DocumentId": string;
    "BlockId": string;
    "Operation": CRDTOp;

    /** Creates a new CRDTOperation instance. */
    constructor($$source: Partial<CRDTOperation> = {}) {
        if (!("Type" in $$source)) {
            this["Type"] = "";
        }
        if (!("BlockType" in $$source)) {
            this["BlockType"] = "";
        }
        if (!("Origin" in $$source)) {
            this["Origin"] = "";
        }
        if (!("OperationId" in $$source)) {
            this["OperationId"] = 0;
        }
        if (!("DocumentId" in $$source)) {
            this["DocumentId"] = "";
        }
        if (!("BlockId" in $$source)) {
            this["BlockId"] = "";
        }
        if (!("Operation" in $$source)) {
            this["Operation"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new CRDTOperation instance from a string or object.
     */
    static createFrom($$source: any = {}): CRDTOperation {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new CRDTOperation($$parsedSource as Partial<CRDTOperation>);
    }
}

/**
 * CRDTOperationsMessage describes a message that contains a list of CRDT operations.
 * 
 * - implements types.Message
 */
export class CRDTOperationsMessage {
    "Operations": CRDTOperation[];

    /** Creates a new CRDTOperationsMessage instance. */
    constructor($$source: Partial<CRDTOperationsMessage> = {}) {
        if (!("Operations" in $$source)) {
            this["Operations"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new CRDTOperationsMessage instance from a string or object.
     */
    static createFrom($$source: any = {}): CRDTOperationsMessage {
        const $$createField0_0 = $$createType2;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Operations" in $$parsedSource) {
            $$parsedSource["Operations"] = $$createField0_0($$parsedSource["Operations"]);
        }
        return new CRDTOperationsMessage($$parsedSource as Partial<CRDTOperationsMessage>);
    }
}

/**
 * FileInfo is used in a search reply to tell about a data blob ("file")
 * being available on a peer.
 * 
 * - implements types.Message
 * - implemented in HW2
 */
export class FileInfo {
    "Name": string;
    "Metahash": string;

    /**
     * len(Chunks) must be of the total number of chunks for that file and
     * chunks must be in order. The stored value is either the chunk key if
     * the chunk is available or nil if not.
     * For example:
     * 
     *   [ []byte("aa"), nil, []byte("cc"), []byte("dd"), nil, nil ]
     * 
     * Means that the file has 6 chunks, but the peer only has 3 (keys "aa", "cc", "dd").
     */
    "Chunks": string[];

    /** Creates a new FileInfo instance. */
    constructor($$source: Partial<FileInfo> = {}) {
        if (!("Name" in $$source)) {
            this["Name"] = "";
        }
        if (!("Metahash" in $$source)) {
            this["Metahash"] = "";
        }
        if (!("Chunks" in $$source)) {
            this["Chunks"] = [];
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new FileInfo instance from a string or object.
     */
    static createFrom($$source: any = {}): FileInfo {
        const $$createField2_0 = $$createType3;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Chunks" in $$parsedSource) {
            $$parsedSource["Chunks"] = $$createField2_0($$parsedSource["Chunks"]);
        }
        return new FileInfo($$parsedSource as Partial<FileInfo>);
    }
}

/**
 * Message defines the type of message that can be marshalled/unmarshalled over
 * the network.
 */
export type Message = any;

/**
 * PaxosValue defines the value on which Paxos makes a consensus.
 */
export class PaxosValue {
    "Filename": string;
    "Metahash": string;

    /** Creates a new PaxosValue instance. */
    constructor($$source: Partial<PaxosValue> = {}) {
        if (!("Filename" in $$source)) {
            this["Filename"] = "";
        }
        if (!("Metahash" in $$source)) {
            this["Metahash"] = "";
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new PaxosValue instance from a string or object.
     */
    static createFrom($$source: any = {}): PaxosValue {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new PaxosValue($$parsedSource as Partial<PaxosValue>);
    }
}

/**
 * Rumor wraps a message to ensure delivery to all peers-
 */
export class Rumor {
    /**
     * Origin is the address of the node that initiated the rumor
     */
    "Origin": string;

    /**
     * Sequence is the unique ID of the packet from packet's creator point of
     * view. Each time a sender creates a packet, it must increment its sequence
     * number and include it. Start from 1.
     */
    "Sequence": number;

    /**
     * The message the rumor embeds.
     */
    "Msg": transport$0.Message | null;

    /** Creates a new Rumor instance. */
    constructor($$source: Partial<Rumor> = {}) {
        if (!("Origin" in $$source)) {
            this["Origin"] = "";
        }
        if (!("Sequence" in $$source)) {
            this["Sequence"] = 0;
        }
        if (!("Msg" in $$source)) {
            this["Msg"] = null;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Rumor instance from a string or object.
     */
    static createFrom($$source: any = {}): Rumor {
        const $$createField2_0 = $$createType5;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Msg" in $$parsedSource) {
            $$parsedSource["Msg"] = $$createField2_0($$parsedSource["Msg"]);
        }
        return new Rumor($$parsedSource as Partial<Rumor>);
    }
}

/**
 * SearchRequestMessage describes a request to search for a data blob.
 * 
 * - implements types.Message
 * - implemented in HW2
 */
export class SearchRequestMessage {
    /**
     * RequestID must be a unique identifier. Use xid.New().String() to generate
     * it.
     */
    "RequestID": string;

    /**
     * Origin is the address of the peer that initiated the search request.
     */
    "Origin": string;

    /**
     * use regexp.MustCompile(Pattern) to convert a string to a regexp.Regexp
     */
    "Pattern": string;
    "Budget": number;

    /** Creates a new SearchRequestMessage instance. */
    constructor($$source: Partial<SearchRequestMessage> = {}) {
        if (!("RequestID" in $$source)) {
            this["RequestID"] = "";
        }
        if (!("Origin" in $$source)) {
            this["Origin"] = "";
        }
        if (!("Pattern" in $$source)) {
            this["Pattern"] = "";
        }
        if (!("Budget" in $$source)) {
            this["Budget"] = 0;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new SearchRequestMessage instance from a string or object.
     */
    static createFrom($$source: any = {}): SearchRequestMessage {
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        return new SearchRequestMessage($$parsedSource as Partial<SearchRequestMessage>);
    }
}

// Private type creation functions
const $$createType0 = PaxosValue.createFrom;
const $$createType1 = CRDTOperation.createFrom;
const $$createType2 = $Create.Array($$createType1);
const $$createType3 = $Create.Array($Create.ByteSlice);
const $$createType4 = transport$0.Message.createFrom;
const $$createType5 = $Create.Nullable($$createType4);
