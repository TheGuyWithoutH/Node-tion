// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT
import {types} from '../models';
import {transport} from '../models';
import {peer} from '../models';
import {regexp} from '../models';
import {sync} from '../models';
import {time} from '../models';
import {io} from '../models';

export function AckMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function AckTicker(arg1:transport.Header,arg2:transport.Message):Promise<void>;

export function AddBlockAndName(arg1:types.BlockchainBlock):Promise<void>;

export function AddMark(arg1:types.TextStyle,arg2:types.CRDTAddMark):Promise<types.TextStyle>;

export function AddPeer(arg1:Array<string>):Promise<void>;

export function AddRequest(arg1:string):Promise<boolean>;

export function AntiEntropyTicker():Promise<void>;

export function ApplyOperation(arg1:types.CRDTOperation):Promise<void>;

export function Broadcast(arg1:transport.Message):Promise<void>;

export function CRDTOperationsMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function CastAndSetOperation(arg1:types.CRDTOperation,arg2:types.CRDTOp):Promise<void>;

export function CastAndSetProps(arg1:types.BlockTypeName,arg2:any):Promise<types.BlockType>;

export function CastOperation(arg1:types.CRDTOperation):Promise<void>;

export function ChatMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function CompileDocument(arg1:string):Promise<string>;

export function CreateBlock(arg1:types.BlockTypeName,arg2:types.DefaultBlockProps,arg3:string):Promise<types.BlockType>;

export function CreateBudgetMap(arg1:number,arg2:number):Promise<{[key: number]: number}>;

export function DataReplyMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function DataRequestMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function DeleteAck(arg1:string):Promise<void>;

export function DeleteDataReplyChan(arg1:string):Promise<void>;

export function DeleteSearchReplyChan(arg1:string):Promise<void>;

export function Download(arg1:string):Promise<Array<number>>;

export function DownloadElement(arg1:string):Promise<Array<number>>;

export function EmptyMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function ExpandRing(arg1:peer.ExpandingRing,arg2:string,arg3:regexp.Regexp,arg4:number,arg5:sync.WaitGroup,arg6:any):Promise<void>;

export function ExportCRDTAddBlock(arg1:types.CRDTAddBlock):Promise<void>;

export function ExportCRDTAddMark(arg1:types.CRDTAddMark):Promise<void>;

export function ExportCRDTDeleteChar(arg1:types.CRDTDeleteChar):Promise<void>;

export function ExportCRDTInsertChar(arg1:types.CRDTInsertChar):Promise<void>;

export function ExportCRDTRemoveBlock(arg1:types.CRDTRemoveBlock):Promise<void>;

export function ExportCRDTRemoveMark(arg1:types.CRDTRemoveMark):Promise<void>;

export function ExportCRDTUpdateBlock(arg1:types.CRDTUpdateBlock):Promise<void>;

export function FilterOps(arg1:Array<types.CRDTOperation>,arg2:string):Promise<Array<types.CRDTOperation>>;

export function ForwardSearchRequest(arg1:number,arg2:string,arg3:regexp.Regexp,arg4:types.SearchRequestMessage):Promise<void>;

export function GetAck(arg1:string):Promise<any|boolean>;

export function GetAddress():Promise<string>;

export function GetBlockOps(arg1:string,arg2:string):Promise<Array<types.CRDTOperation>>;

export function GetCRDTState(arg1:string):Promise<number>;

export function GetCatalog():Promise<peer.Catalog>;

export function GetDocumentList():Promise<Array<string>>;

export function GetDocumentOps(arg1:string):Promise<{[key: string]: Array<types.CRDTOperation>}>;

export function GetEditor():Promise<peer.Editor>;

export function GetFileInfo(arg1:string,arg2:string):Promise<types.FileInfo>;

export function GetNeighbors(arg1:Array<string>):Promise<Array<string>>;

export function GetRandNeighsFromBudget(arg1:number,arg2:Array<string>):Promise<Array<string>>;

export function GetRandomNeighborFromRoutingTable(arg1:string):Promise<string>;

export function GetRandomPeerFromCatalog(arg1:string):Promise<string>;

export function GetRoutingTable():Promise<peer.RoutingTable>;

export function GetTmpID(arg1:number):Promise<number>;

export function HeartbeatTicker():Promise<void>;

export function HexEncode(arg1:Array<number>):Promise<string>;

export function Listen():Promise<void>;

export function PaxosAcceptMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function PaxosLoop(arg1:string,arg2:string):Promise<void>;

export function PaxosPrepareMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function PaxosPromiseMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function PaxosProposeMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function PrivateMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function ProcessMsg(arg1:transport.Packet):Promise<void>;

export function ProcessRumor(arg1:types.Rumor,arg2:transport.Packet):Promise<void>;

export function RelayMsg(arg1:transport.Packet):Promise<void>;

export function RemoteDownload(arg1:string):Promise<Array<number>>;

export function RemoveMark(arg1:types.TextStyle,arg2:string):Promise<types.TextStyle>;

export function RemovePeerFromCatalog(arg1:string,arg2:string):Promise<void>;

export function Resolve(arg1:string):Promise<string>;

export function RumorsMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function SaveTransactions(arg1:types.CRDTOperationsMessage):Promise<void>;

export function SearchAll(arg1:regexp.Regexp,arg2:number,arg3:time.Duration):Promise<Array<string>>;

export function SearchFirst(arg1:regexp.Regexp,arg2:peer.ExpandingRing):Promise<string>;

export function SearchFirstLocal(arg1:regexp.Regexp):Promise<string>;

export function SearchMatch(arg1:regexp.Regexp):Promise<Array<string>>;

export function SearchReplyMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function SearchRequestMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function SendAckMessage(arg1:transport.Packet):Promise<void>;

export function SendDataRequestMessage(arg1:string,arg2:string,arg3:string):Promise<void>;

export function SendHeartbeat():Promise<void>;

export function SendMsg(arg1:string,arg2:types.Message):Promise<void>;

export function SendRumorsMessage(arg1:transport.Packet,arg2:Array<types.Rumor>):Promise<void>;

export function SendRumorsMessageRand(arg1:transport.Message,arg2:string):Promise<transport.Header>;

export function SendSearchRequestMessage(arg1:string,arg2:regexp.Regexp,arg3:number,arg4:string,arg5:string):Promise<void>;

export function SendStatusMessage(arg1:string,arg2:{[key: string]: number}):Promise<void>;

export function SendWithProbability(arg1:transport.Packet,arg2:{[key: string]: number}):Promise<void>;

export function SetAck(arg1:string,arg2:any):Promise<void>;

export function SetDataReplyChan(arg1:string,arg2:any):Promise<void>;

export function SetRoutingEntry(arg1:string,arg2:string):Promise<void>;

export function SetSearchReplyChan(arg1:string,arg2:any):Promise<void>;

export function SortInsertOps(arg1:Array<types.CRDTOperation>,arg2:Array<types.CRDTOperation>):Promise<Array<types.CRDTInsertChar>>;

export function SplitMetafile(arg1:Array<number>):Promise<Array<string>>;

export function Start():Promise<void>;

export function StatusMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function Stop():Promise<void>;

export function StoreDocument(arg1:string,arg2:string):Promise<void>;

export function TLCMessageCallback(arg1:types.Message,arg2:transport.Packet):Promise<void>;

export function TLCStepReset():Promise<void>;

export function Tag(arg1:string,arg2:string):Promise<void>;

export function TryBroadcast(arg1:types.Message):Promise<void>;

export function Unicast(arg1:string,arg2:transport.Message):Promise<void>;

export function UpdateCatalog(arg1:string,arg2:string):Promise<void>;

export function UpdateEditor(arg1:Array<types.CRDTOperation>):Promise<void>;

export function Upload(arg1:io.Reader):Promise<string>;
